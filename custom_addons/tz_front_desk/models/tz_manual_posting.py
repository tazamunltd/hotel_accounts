from Tools.scripts.dutree import store
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from datetime import datetime, timedelta

import logging

_logger = logging.getLogger(__name__)


class TzHotelManualPosting(models.Model):
    """
    The Manual Postings form is a crucial part of the hotel’s financial system.
    It offers accountants and Front Office staff the ability to enter or adjust financial transactions that are not automatically generated by the system’s standard processes
    (e.g., daily room charges or integrated point-of-sale sales).
    """
    _name = 'tz.manual.posting'
    _order = 'create_date asc'
    _description = 'Hotel Manual Posting'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(
        string="Transaction ID",
        readonly=True,
        index=True,
        default='New',
        tracking=True
    )

    date = fields.Date(
        string="Date / Shift #",
        default=lambda self: self.env.company.system_date.replace(hour=0, minute=0, second=0, microsecond=0),
        readonly=True
    )
    time = fields.Char(
        string="Time",
        compute='_compute_current_time',
        store=True,
        default=lambda self: datetime.now().strftime('%H:%M %p')
    )

    company_id = fields.Many2one('res.company', string="Hotel",
                                 index=True,
                                 default=lambda self: self.env.company,
                                 readonly=True)

    item_id = fields.Many2one('posting.item', string="Item", index=True, required=True, tracking=True)
    item_description = fields.Char(related='item_id.description', string='Item Description')

    description = fields.Char(string=_("Description"), required=True, readonly=False)

    voucher_number = fields.Char(string="Voucher #", index=True, tracking=True)

    room_list = fields.Many2one(
        'hotel.room',
        string="Room",
        domain="[('id', 'in', unavailable_room_ids)]"
    )

    unavailable_room_ids = fields.Many2many(
        comodel_name='hotel.room',
        compute='_compute_unavailable_rooms',
        store=False,
    )

    group_list = fields.Many2one(
        'group.booking',
        string="Group",
        domain="[('status_code', '=', 'confirmed'), ('has_master_folio', '=', True)]"
    )

    dummy_list = fields.Many2one(
        'tz.dummy.group',
        string="Dummy",
        domain="[('obsolete', '=', False)]"
    )

    all_group = fields.Selection(
        selection='_get_all_group_selection',
        string="Group or Dummy Group"
    )

    type = fields.Selection(
        [
            ('booking', 'Booking'),
            ('room', 'Room'),
            ('group', 'Group'),
        ],
        string="Type",
        default='room',
        tracking=True
    )

    debit_amount = fields.Float(
        string="Debit",
        tracking=True,
        index=True,
    )
    credit_amount = fields.Float(
        string="Credit",
        tracking=True,
        index=True,
    )
    quantity = fields.Integer(string="Quantity", default=1, tracking=True, index=True)
    total = fields.Float(string="Total", tracking=True, index=True, compute='_compute_total', store=True)
    balance = fields.Float(string="Balance", compute='_compute_balance', store=True)

    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        readonly=True,
        default=lambda self: self.env.company.currency_id
    )

    sign = fields.Selection(
        selection=[
            ('debit', 'Debit'),
            ('credit', 'Credit')
        ],
        string="Sign",
        store=True,
        tracking=True,
        compute='_compute_sign',
    )

    taxes = fields.Many2many('account.tax', string="Taxes", compute='_compute_taxes', store=True)

    partner_id = fields.Many2one(
        'res.partner',
        string="Guest",
        compute='_compute_booking_info',
        store=True
    )

    reference_contact_ = fields.Char(
        string="Contact Reference",
        compute='_compute_booking_info',
        store=True
    )
    folio_id = fields.Many2one('tz.master.folio', string="Folio", index=True, store=True)

    source_type = fields.Selection(
        [('auto', 'Auto'), ('manual', 'Manual')],
        string="Source",
        default='manual',
        tracking=True
    )

    price = fields.Float(
        string="Price",
        compute='_compute_price',
        help="Shows either debit or credit amount, whichever is non-zero"
    )

    state = fields.Selection(
        [('draft', 'Draft'), ('posted', 'Posted')],
        string="State",
        default='draft',
        tracking=True
    )

    booking_id = fields.Many2one(
        'room.booking',
        string="Room Booking"
    )

    tax_ids = fields.One2many('tz.manual.posting.tax', 'posting_id', string='Taxes')

    debit_without_vat = fields.Float(string="Debit", index=True)
    credit_without_vat = fields.Float(string="Credit", index=True)

    @api.model
    def default_get(self, fields_list):
        res = super(TzHotelManualPosting, self).default_get(fields_list)
        unavailable_rooms = self.env['room.booking.line'].search([
            ('state_', 'in', ['confirmed', 'block', 'check_in', 'no_show']),
        ]).mapped('room_id.id')
        res['unavailable_room_ids'] = [(6, 0, unavailable_rooms)]
        return res

    @api.model
    def create(self, vals):
        if not vals.get('sign'):
            raise ValidationError("You must select a Sign before creating a manual posting.")

        # Optimized sequence generation
        if vals.get('name', 'New') == 'New':
            company = self.env.company  # Directly get current company
            vals[
                'name'] = f"{company.name}/{self.env['ir.sequence'].with_company(company).next_by_code('tz.manual.posting') or '00001'}"

        if self._context.get('manual_creation'):
            if vals.get('group_list', False):
                vals['room_list'] = self._get_master_room_id(vals['group_list'])

            vals['source_type'] = 'manual'

        record = super(TzHotelManualPosting, self).create(vals)

        # Optimize folio linking - consider making this a separate method or async
        if self._context.get('manual_creation') and not record.folio_id:
            folio = False
            if record.room_list:
                folio = record._create_master_folio(record.room_list.id)
            elif record.dummy_list:
                folio = record._get_master_folio_for_dummy(record.dummy_list.id)
            record.folio_id = folio

        if record.item_id:
            record.compute_manual_taxes()
        return record

    def write(self, vals):
        res = super().write(vals)

        for rec in self:
            needs_recompute = False
            posting_tax = self.env['tz.manual.posting.tax']

            if 'item_id' in vals:
                # Remove old tax records before recomputing
                posting_tax = posting_tax.search([
                    ('company_id', '=', rec.company_id.id),
                    ('posting_id', '=', rec.id),
                    ('date', '=', rec.date),
                    ('time', '=', rec.time),
                    ('description', '!=', rec.item_id.description or 'Room Charge')
                ])
                needs_recompute = True

            if any(key in vals for key in ['debit_amount', 'credit_amount']):
                needs_recompute = True

            if needs_recompute:
                # Delete old taxes first if changing item_id
                if posting_tax:
                    posting_tax.unlink()
                rec.compute_manual_taxes()

        return res

    def _compute_unavailable_rooms(self):
        for rec in self:
            unavailable_rooms = self.env['room.booking.line'].search([
                ('state_', 'in', ['confirmed', 'block', 'check_in', 'no_show']),
            ]).mapped('room_id.id')
            rec.unavailable_room_ids = unavailable_rooms

    @api.depends('debit_amount', 'credit_amount', 'quantity')
    def _compute_total(self):
        for record in self:
            if record.sign == 'debit' and record.debit_amount > 0:
                record.total = record.debit_amount * record.quantity
            elif record.sign == 'credit' and record.credit_amount > 0:
                record.total = record.credit_amount * record.quantity
            else:
                record.total = 0.0

    @api.depends('folio_id', 'debit_without_vat', 'credit_without_vat')
    def _compute_balance(self):
        for folio in self.mapped('folio_id'):
            lines = folio.manual_posting_ids.sorted(key=lambda r: (r.date, r.id))
            running_balance = 0
            for line in lines:
                running_balance += line.debit_without_vat - line.credit_without_vat
                line.balance = running_balance

    @api.depends('room_list')
    def _compute_booking_info(self):
        for record in self:
            booking_line = self.env['room.booking.line'].search([
                ('room_id', '=', record.room_list.id),
                ('state_', 'in', ['confirmed', 'block', 'check_in', 'no_show'])
            ], limit=1)

            if booking_line and booking_line.booking_id:
                record.partner_id = booking_line.booking_id.partner_id
                record.reference_contact_ = booking_line.booking_id.reference_contact_
            else:
                record.partner_id = False
                record.reference_contact_ = False

    @api.depends()
    def _compute_current_time(self):
        """Compute current time in '%H:%M %p' format (e.g., '02:30 PM')"""
        current_time = datetime.now().strftime('%H:%M %p')
        for record in self:
            record.time = current_time

    def _get_master_room_id(self, group_id):
        if group_id:
            system_date = self.env.company.system_date.date()
            # Get all bookings for this group
            bookings = self.env['room.booking'].search([
                ('company_id', '=', self.env.company.id),
                ('group_booking', '=', group_id),
                ('checkin_date', '>=', fields.Datetime.to_datetime(system_date)),
                ('checkin_date', '<', fields.Datetime.to_datetime(system_date + timedelta(days=1))),
            ])

            # Find master bookings (where parent_booking_name is null)
            master_bookings = bookings.filtered(lambda b: not b.parent_booking_name)

            if not master_bookings:
                return False

            # Use the first master booking
            master_booking = master_bookings[0]

            # Return first room if multiple exist
            return master_booking.room_line_ids[0].room_id.id if master_booking.room_line_ids else False

    @api.depends('item_id.taxes')
    def _compute_taxes(self):
        for rec in self:
            rec.taxes = rec.item_id.taxes

    @api.depends('debit_amount', 'credit_amount')
    def _compute_price(self):
        for record in self:
            record.price = record.debit_amount or record.credit_amount

    @api.onchange('booking_id', 'room_list', 'group_list')
    def _onchange_booking_room_or_group(self):
        """Automatically find and suggest folio when booking, room or group changes"""
        if self.booking_id or self.room_list or self.group_list:
            self.folio_id = False
            domain = []
            if self.booking_id:
                domain.append(('booking_ids', 'in', self.booking_id.id))
            if self.room_list:
                domain.append(('room_id', '=', self.room_list.id))
            if self.group_list:
                domain.append(('group_id', '=', self.group_list.id))

            if self.room_list and self.group_list:
                folio = self.env['tz.master.folio'].search([
                    '|',
                    ('room_id', '=', self.room_list.id),
                    ('group_id', '=', self.group_list.id)
                ], limit=1, order='create_date DESC')
            elif domain:
                folio = self.env['tz.master.folio'].search(domain, limit=1, order='create_date DESC')
                # raise UserError(folio)
            else:
                folio = False
            self.folio_id = folio

    @api.onchange('item_id')
    def _onchange_item_id(self):
        if self.item_id:
            self.sign = self.item_id.default_sign

            # Set the amount based on the sign
            if self.sign == 'debit':
                self.debit_amount = self.item_id.default_value
                self.credit_amount = 0.0
            elif self.sign == 'credit':
                self.credit_amount = self.item_id.default_value
                self.debit_amount = 0.0
            self.description = self.item_id.description

    @api.onchange('type')
    def _onchange_type(self):
        self.room_list = False
        self.group_list = False
        self.booking_id = False
        self.folio_id = False

    def _create_master_folio(self, room_id):
        """
        Create master folio for manual posting when none exists
        Returns folio ID or raises exception
        """
        system_date = self.env.company.system_date.date()

        # check room id from
        booking_line = self.env['room.booking.line'].search([
            ('room_id', '=', room_id),
            ('checkin_date', '>=', fields.Datetime.to_datetime(system_date)),
            ('checkin_date', '<', fields.Datetime.to_datetime(system_date + timedelta(days=1))),
            ('state_', 'in', ['confirmed', 'block', 'check_in', 'no_show'])
        ], limit=1)

        domain = self._get_domain_filter(room_id, system_date)

        if booking_line.booking_id.group_booking:
            folio = self.env['tz.master.folio'].sudo().search(domain, limit=1)
            if not folio:
                company = self.env.company
                prefix = f"{company.name}/"
                folio_name = prefix + (self.env['ir.sequence'].sudo().with_company(company)
                                       .next_by_code('tz.master.folio'))

                folio_vals = {
                    'name': folio_name,
                    'guest_id': booking_line.booking_id.partner_id.id,
                    'rooming_info': booking_line.room_id.name,
                    'check_in': booking_line.checkin_date,
                    'check_out': booking_line.checkout_date,
                    'company_id': company.id,
                    'currency_id': company.currency_id.id,
                    'room_id': room_id,
                    'booking_ids': [(4, booking_line.booking_id.id)],
                }
                # raise UserError("\n".join([f"{key}: {value}" for key, value in folio_vals.items()]))
                folio = self.env['tz.master.folio'].sudo().create(folio_vals)
            return folio
        else:
            return self.env['tz.master.folio'].sudo().search(domain, limit=1)

    def _get_domain_filter(self, room_id, system_date):
        return [
            ('company_id', '=', self.env.company.id),
            ('room_id', '=', room_id),
            ('check_in', '>=', fields.Datetime.to_datetime(system_date)),
            ('check_in', '<', fields.Datetime.to_datetime(system_date + timedelta(days=1)))
        ]

    def _get_master_folio_for_dummy(self, dummy_id):
        return self.env['tz.master.folio'].sudo().search([
            ('company_id', '=', self.env.company.id),
            ('dummy_id', '=', dummy_id),
        ], limit=1)

    @api.depends('item_id.default_sign')
    def _compute_sign(self):
        for rec in self:
            if rec.item_id.default_sign == 'debit' or rec.item_id.default_sign == 'credit':
                rec.sign = rec.item_id.default_sign

    @api.model
    def _get_all_group_selection(self):
        # Dummy Groups: all records from tz.dummy.group
        dummy_groups = self.env['tz.dummy.group'].search([('obsolete', '=', False)])

        # Group Bookings: only confirmed and having a master folio
        group_bookings = self.env['group.booking'].search([
            ('status_code', '=', 'confirmed'),
            ('has_master_folio', '=', True)
        ])

        result = []

        # Add dummy groups to selection
        for dummy in dummy_groups:
            result.append((f'dummy_{dummy.id}', f'Dummy Group: {dummy.name}'))

        # Add group bookings to selection
        for group in group_bookings:
            result.append((f'group_{group.id}', f'Group: {group.name}'))

        return result

    @api.onchange('all_group')
    def _onchange_all_group(self):
        """Automatically populate group_list or dummy_list based on all_group selection."""
        self.group_list = False
        self.dummy_list = False

        if self.all_group:
            type_str, rec_id = self.all_group.split('_')
            rec_id = int(rec_id)

            if type_str == 'dummy':
                self.dummy_list = self.env['tz.dummy.group'].browse(rec_id)
            elif type_str == 'group':
                self.group_list = self.env['group.booking'].browse(rec_id)

    def get_selected_group_record(self):
        """Returns the actual record selected in all_group."""
        if self.all_group:
            type_str, rec_id = self.all_group.split('_')
            rec_id = int(rec_id)
            if type_str == 'dummy':
                return self.env['tz.dummy.group'].browse(rec_id)
            elif type_str == 'group':
                return self.env['group.booking'].browse(rec_id)
        return None

    def compute_and_create_taxes(self):
        self.ensure_one()
        self.tax_ids.unlink()  # Always clear existing tax lines before recompute

        if not self.item_id or not self.item_id.taxes:
            return

        # Total amount input by user
        total_amount = self.debit_amount or self.credit_amount
        if not total_amount:
            return

        # Calculate taxes from included price
        taxes = self.item_id.taxes.with_context(price_include=True).compute_all(
            total_amount,
            currency=self.currency_id,
            quantity=1.0,
            product=self.item_id,
            partner=self.partner_id,
        )

        for tax in taxes['taxes']:
            self.env['tz.manual.posting.tax'].create({
                'posting_id': self.id,
                'tax_type': tax['name'],
                'item_description': tax['name'],
                'debit_amount': tax['amount'] if self.debit_amount else 0.0,
                'credit_amount': tax['amount'] if self.credit_amount else 0.0,
                'balance': tax['amount'],
            })

    def compute_manual_taxes(self):
        tax_model = self.env['tz.manual.posting.tax']
        for rec in self:
            taxes = rec.item_id.taxes
            total = rec.debit_amount if rec.sign == 'debit' else rec.credit_amount
            if not total or total <= 0:
                continue

            tax_lines = []

            if taxes:
                # Initialize variables for tax rates
                vat_rate = 0.0
                municipality_rate = 0.0

                for tax in taxes:
                    if 'vat' in tax.description.lower():
                        vat_rate = tax.amount / 100.0
                    else:
                        municipality_rate = tax.amount / 100.0

                vat_divisor = 1 + vat_rate
                municipality_divisor = 1 + municipality_rate

                vat_amount = total - (total / vat_divisor)
                amount_after_vat = total - vat_amount
                municipality_amount = amount_after_vat - (amount_after_vat / municipality_divisor)
                room_charge = total - vat_amount - municipality_amount
            else:
                # No taxes, so room_charge is the total amount
                vat_amount = 0.0
                municipality_amount = 0.0
                room_charge = total

            # Always add Room Charge or item description
            tax_lines.append({
                'date': rec.date,
                'time': rec.time,
                'description': rec.item_id.description or 'Room Charge',
                'debit_amount': round(room_charge, 2) if rec.sign == 'debit' else 0.0,
                'credit_amount': round(room_charge, 2) if rec.sign == 'credit' else 0.0,
                'balance': round(room_charge, 2) if rec.sign == 'debit' else -round(room_charge, 2),
                'posting_id': rec.id,
                'type': 'amount',
            })

            # Add tax lines only if taxes exist
            if taxes:
                for tax in taxes:
                    if 'vat' in tax.description.lower():
                        tax_lines.append({
                            'date': rec.date,
                            'time': rec.time,
                            'description': tax.description,
                            'debit_amount': round(vat_amount, 2) if rec.sign == 'debit' else 0.0,
                            'credit_amount': round(vat_amount, 2) if rec.sign == 'credit' else 0.0,
                            'balance': round(vat_amount, 2) if rec.sign == 'debit' else -round(vat_amount, 2),
                            'posting_id': rec.id,
                            'type': 'vat',
                        })
                    else:
                        tax_lines.append({
                            'date': rec.date,
                            'time': rec.time,
                            'description': tax.description,
                            'debit_amount': round(municipality_amount, 2) if rec.sign == 'debit' else 0.0,
                            'credit_amount': round(municipality_amount, 2) if rec.sign == 'credit' else 0.0,
                            'balance': round(municipality_amount, 2) if rec.sign == 'debit' else -round(
                                municipality_amount, 2),
                            'posting_id': rec.id,
                            'type': 'municipality',
                        })

            # Create tax lines with non-zero values
            for line in tax_lines:
                if line['debit_amount'] > 0 or line['credit_amount'] > 0:
                    tax_model.create(line)

            # Save net amounts
            rec.write({
                'debit_without_vat': round(room_charge, 2) if rec.sign == 'debit' else 0.0,
                'credit_without_vat': round(room_charge, 2) if rec.sign == 'credit' else 0.0,
            })

            rec.update_folio_debit_credit_and_taxes()

    # def compute_manual_taxes(self):
    #     tax_model = self.env['tz.manual.posting.tax']
    #     for rec in self:
    #         taxes = rec.item_id.taxes
    #         if not taxes:
    #             continue  # Skip if item has no taxes
    #
    #         # Determine the total amount based on the sign
    #         total = rec.debit_amount if rec.sign == 'debit' else rec.credit_amount
    #         if not total or total <= 0:
    #             continue
    #
    #         # Initialize variables for tax rates
    #         vat_rate = 0.0
    #         municipality_rate = 0.0
    #
    #         # Get rates from taxes field
    #         for tax in taxes:
    #             if 'vat' in tax.description.lower():
    #                 vat_rate = tax.amount / 100.0  # Convert percentage to decimal
    #             else:
    #                 municipality_rate = tax.amount / 100.0  # Convert percentage to decimal
    #
    #         # Calculate amounts using dynamic rates
    #         vat_divisor = 1 + vat_rate
    #         municipality_divisor = 1 + municipality_rate
    #
    #         # Calculate VAT
    #         vat_amount = total - (total / vat_divisor)
    #
    #         # Calculate amount after VAT
    #         amount_after_vat = total - vat_amount
    #
    #         # Calculate Municipality (from amount after VAT)
    #         municipality_amount = amount_after_vat - (amount_after_vat / municipality_divisor)
    #
    #         # Calculate Room Charge (net amount)
    #         room_charge = total - vat_amount - municipality_amount
    #
    #         tax_lines = []
    #
    #         # Create tax lines in the correct order
    #         for tax in taxes:
    #             if 'vat' in tax.description.lower():
    #                 # VAT line
    #                 tax_lines.append({
    #                     'date': rec.date,
    #                     'time': rec.time,
    #                     'description': tax.description,
    #                     'debit_amount': round(vat_amount, 2) if rec.sign == 'debit' else 0.0,
    #                     'credit_amount': round(vat_amount, 2) if rec.sign == 'credit' else 0.0,
    #                     'balance': round(vat_amount, 2) if rec.sign == 'debit' else -round(vat_amount, 2),
    #                     'posting_id': rec.id,
    #                     'type': 'vat',
    #                 })
    #             else:
    #                 # Municipality line
    #                 tax_lines.append({
    #                     'date': rec.date,
    #                     'time': rec.time,
    #                     'description': tax.description,
    #                     'debit_amount': round(municipality_amount, 2) if rec.sign == 'debit' else 0.0,
    #                     'credit_amount': round(municipality_amount, 2) if rec.sign == 'credit' else 0.0,
    #                     'balance': round(municipality_amount, 2) if rec.sign == 'debit' else -round(municipality_amount,
    #                                                                                                 2),
    #                     'posting_id': rec.id,
    #                     'type': 'municipality',
    #                 })
    #
    #         # Add Room Charge as the first record
    #         tax_lines.insert(0, {
    #             'date': rec.date,
    #             'time': rec.time,
    #             'description': rec.item_id.description or 'Room Charge',
    #             'debit_amount': round(room_charge, 2) if rec.sign == 'debit' else 0.0,
    #             'credit_amount': round(room_charge, 2) if rec.sign == 'credit' else 0.0,
    #             'balance': round(room_charge, 2) if rec.sign == 'debit' else -round(room_charge, 2),
    #             'posting_id': rec.id,
    #             'type': 'amount',
    #         })
    #
    #         # Create records with non-zero values
    #         for line in tax_lines:
    #             if line['debit_amount'] > 0 or line['credit_amount'] > 0:
    #                 tax_model.create(line)
    #
    #         rec.write({
    #             'debit_without_vat': round(room_charge, 2) if rec.sign == 'debit' else 0.0,
    #             'credit_without_vat': round(room_charge, 2) if rec.sign == 'credit' else 0.0,
    #         })
    #         rec.update_folio_debit_credit_and_taxes()
    #         raise UserError(rec.item_id.taxes)

    def update_folio_debit_credit_and_taxes(self):
        for rec in self:
            # Filter postings for the same folio and context
            domain = [
                ('company_id', '=', rec.company_id.id),
                ('folio_id', '=', rec.folio_id.id),
                ('date', '=', rec.date),
            ]

            postings = self.search(domain)
            total_debit = sum(post.debit_without_vat for post in postings)
            total_credit = sum(post.credit_without_vat for post in postings)

            # Tax aggregation from tax model
            tax_domain = [
                ('company_id', '=', rec.company_id.id),
                ('posting_id.folio_id', '=', rec.folio_id.id),
                ('date', '=', rec.date),
            ]

            taxes = self.env['tz.manual.posting.tax'].search(tax_domain)
            total_vat = sum(t.balance for t in taxes if t.type == 'vat')
            total_municipality = sum(t.balance for t in taxes if t.type == 'municipality')

            rec.folio_id.sudo().write({
                'total_debit': round(total_debit, 2),
                'total_credit': round(total_credit, 2),
                'value_added_tax': round(total_vat, 2),
                'municipality_tax': round(total_municipality, 2),
            })

    def unlink(self):
        for record in self:
            if record.state == 'posted':
                raise UserError(_("You cannot delete a record that is posted."))
        folios_to_update = self.mapped('folio_id')
        dates_to_update = self.mapped('date')
        companies_to_update = self.mapped('company_id')

        # Store context values before deletion
        records_context = [(rec.folio_id, rec.company_id, rec.date) for rec in self]

        # Proceed with standard deletion
        res = super(TzHotelManualPosting, self).unlink()

        # Now update each affected folio after deletion
        for folio, company, date in records_context:
            # Use sudo if needed to bypass access rules
            relevant_postings = self.sudo().search([
                ('folio_id', '=', folio.id),
                ('company_id', '=', company.id),
                ('date', '=', date),
            ])

            # Use a dummy record to call your existing method
            if relevant_postings:
                relevant_postings.update_folio_debit_credit_and_taxes()
            else:
                # No remaining postings — reset values to zero
                folio.sudo().write({
                    'total_debit': 0.0,
                    'total_credit': 0.0,
                    'value_added_tax': 0.0,
                    'municipality_tax': 0.0,
                })

        return res









