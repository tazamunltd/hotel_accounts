# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class TzHotelManualPosting(models.Model):
    """
    The Manual Postings form is a crucial part of the hotel’s financial system.
    It offers accountants and Front Office staff the ability to enter or adjust financial transactions that are not automatically generated by the system’s standard processes
    (e.g., daily room charges or integrated point-of-sale sales).
    """
    _name = 'tz.manual.posting'
    _order = 'create_date desc'
    _description = 'Hotel Manual Posting'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(
        string="Transaction ID",
        readonly=True,
        index=True,
        default='New',
        tracking=True
    )

    date = fields.Date(
        string="Date / Shift #",
        default=lambda self: self.env.user.company_id.system_date.replace(hour=0, minute=0, second=0, microsecond=0),
        readonly=True
    )
    time = fields.Char(
        string="Time",
        compute='_compute_current_time',
        store=True,
        default=lambda self: datetime.now().strftime('%H:%M %p')
    )

    company_id = fields.Many2one('res.company', string="Hotel",
                                 index=True,
                                 default=lambda self: self.env.company,
                                 readonly=True)

    item_id = fields.Many2one('posting.item', string="Item", index=True, required=True, tracking=True)
    item_description = fields.Char(related='item_id.description', string='Item Description')

    description = fields.Char(string=_("Description"), required=True, readonly=False)

    voucher_number = fields.Char(string="Voucher #", index=True, tracking=True)

    room_list = fields.Many2one(
        'hotel.room',
        string="Room",
        domain="[('id', 'in', unavailable_room_ids)]"
    )

    unavailable_room_ids = fields.Many2many(
        comodel_name='hotel.room',
        compute='_compute_unavailable_rooms',
        store=False,
    )

    group_list = fields.Many2one(
        'group.booking',
        string="Group",
        domain="[('status_code', '=', 'confirmed')]"
    )

    # valid_group_ids = fields.Many2many(
    #     'group.booking',
    #     compute='_compute_valid_groups',
    #     string='Valid Groups'
    # )

    type = fields.Selection(
        [
            ('room', 'Room'),
            ('group', 'Group'),
        ],
        string="Type",
        default='room',
        tracking=True
    )

    debit_amount = fields.Float(
        string="Debit",
        tracking=True,
        index=True,
    )
    credit_amount = fields.Float(
        string="Credit",
        tracking=True,
        index=True,
    )
    quantity = fields.Integer(string="Quantity", default=1, tracking=True, index=True)
    total = fields.Float(string="Total", tracking=True, index=True, compute='_compute_total', store=True)
    balance = fields.Float(string="Balance", compute='_compute_balance', store=True)

    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        readonly=True,
        default=lambda self: self.env.company.currency_id
    )

    sign = fields.Selection(
        selection=[
            ('debit', 'Debit'),
            ('credit', 'Credit')
        ],
        string="Sign",
        store=True,
        tracking=True,
        compute='_compute_sign',
    )

    taxes = fields.Many2many('account.tax', string="Taxes", compute='_compute_taxes', store=True)

    @api.depends('item_id.taxes')
    def _compute_taxes(self):
        for rec in self:
            rec.taxes = rec.item_id.taxes

    partner_id = fields.Many2one(
        'res.partner',
        string="Guest",
        compute='_compute_booking_info',
        store=True
    )

    reference_contact_ = fields.Char(
        string="Contact Reference",
        compute='_compute_booking_info',
        store=True
    )
    folio_id = fields.Many2one('tz.master.folio', string="Folio", index=True)

    source_type = fields.Selection(
        [('auto', 'Auto'), ('manual', 'Manual')],
        string="Source",
        default='manual',
        tracking=True
    )

    price = fields.Float(
        string="Price",
        compute='_compute_price',
        help="Shows either debit or credit amount, whichever is non-zero"
    )

    state = fields.Selection(
        [('draft', 'Draft'), ('posted', 'Posted')],
        string="State",
        default='draft',
        tracking=True
    )

    booking_id = fields.Many2one(
        'room.booking',
        string="Room Booking"
    )

    @api.model
    def default_get(self, fields_list):
        res = super(TzHotelManualPosting, self).default_get(fields_list)
        unavailable_rooms = self.env['room.booking.line'].search([
            ('state_', 'in', ['confirmed', 'block', 'check_in']),
        ]).mapped('room_id.id')
        res['unavailable_room_ids'] = [(6, 0, unavailable_rooms)]
        return res

    @api.model
    def create(self, vals):

        if not vals.get('sign'):
            raise ValidationError("You must select a Sign before creating a manual posting.")

        # Generate sequence if needed
        if vals.get('name', 'New') == 'New':
            company = self.env['res.company'].browse(self.env.company.id)
            prefix = company.name + '/' if company else ''
            next_seq = self.env['ir.sequence'].with_company(company).next_by_code(
                'tz.manual.posting') or '00001'
            vals['name'] = prefix + next_seq

        # Check for duplicates before creation
        if self._context.get('manual_creation'):
            if vals.get('group_list', False):
                vals['room_list'] = self._get_master_room_id(vals['group_list'])

            domain = [
                ('company_id', '=', vals.get('company_id', self.env.company.id)),
                ('date', '=', vals.get('date')),
                ('room_list', '=', vals.get('room_list')),
                ('partner_id', '=', vals.get('partner_id')),
                ('item_id', '=', vals.get('item_id')),
                ('description', '=', vals.get('description')),
            ]

            if vals.get('debit_amount', 0) > 0:
                domain.extend([
                    ('debit_amount', '=', vals['debit_amount']),
                    ('credit_amount', '=', 0)
                ])
            elif vals.get('credit_amount', 0) > 0:
                domain.extend([
                    ('credit_amount', '=', vals['credit_amount']),
                    ('debit_amount', '=', 0)
                ])

            vals['source_type'] = 'manual'

        # Create the record
        record = super(TzHotelManualPosting, self).create(vals)

        if self._context.get('manual_creation') and not record.folio_id:
            record.folio_id = record._create_master_folio(record.room_list.id)
            # raise UserError(record.folio_id)

        return record

    def _compute_unavailable_rooms(self):
        for rec in self:
            unavailable_rooms = self.env['room.booking.line'].search([
                ('state_', 'in', ['confirmed', 'block', 'check_in']),
            ]).mapped('room_id.id')
            rec.unavailable_room_ids = unavailable_rooms

    @api.depends('debit_amount', 'credit_amount', 'quantity')
    def _compute_total(self):
        for record in self:
            if record.sign == 'debit' and record.debit_amount > 0:
                record.total = record.debit_amount * record.quantity
            elif record.sign == 'credit' and record.credit_amount > 0:
                record.total = record.credit_amount * record.quantity

    @api.depends('item_id.default_value', 'sign')
    def _compute_debit_credit_amounts(self):
        for record in self:
            if record.sign == 'debit':
                record.debit_amount = record.item_id.default_value
                record.credit_amount = 0.0
            else:  # credit
                record.credit_amount = record.item_id.default_value
                record.debit_amount = 0.0

    @api.depends('folio_id', 'debit_amount', 'credit_amount')
    def _compute_balance(self):
        for folio in self.mapped('folio_id'):
            lines = folio.manual_posting_ids.sorted(key=lambda r: (r.date, r.id))
            running_balance = 0
            for line in lines:
                running_balance += line.debit_amount - line.credit_amount
                line.balance = running_balance

    @api.depends('room_list')
    def _compute_booking_info(self):
        for record in self:
            booking_line = self.env['room.booking.line'].search([
                ('room_id', '=', record.room_list.id),
                ('state_', 'in', ['confirmed', 'check_in'])
            ], limit=1)

            if booking_line and booking_line.booking_id:
                record.partner_id = booking_line.booking_id.partner_id
                record.reference_contact_ = booking_line.booking_id.reference_contact_
            else:
                record.partner_id = False
                record.reference_contact_ = False

    @api.onchange('room_list')
    def _onchange_room_list(self):
        if not self.room_list:
            self.partner_id = False
            self.reference_contact_ = False
        for record in self:
            if record.room_list:
                # Get the most recent active booking for this room
                booking_line = self.env['room.booking.line'].search([
                    ('room_id', '=', record.room_list.id),
                    ('state_', 'in', ['confirmed', 'check_in'])
                ], order='checkin_date desc', limit=1)

                if booking_line:
                    record.booking_id = booking_line.booking_id

                    # Find folio for this booking
                    folio = self.env['tz.master.folio'].search([
                        ('room_id', '=', record.room_list.id),
                        ('booking_ids', 'in', booking_line.booking_id.id)
                    ], limit=1)
                    record.folio_id = folio
                else:
                    record.booking_id = False
                    record.folio_id = False

    @api.depends()
    def _compute_current_time(self):
        """Compute current time in '%H:%M %p' format (e.g., '02:30 PM')"""
        current_time = datetime.now().strftime('%H:%M %p')
        for record in self:
            record.time = current_time

    def _get_master_room_id(self, group_id):
        if group_id:
            # Get all bookings for this group
            bookings = self.env['room.booking'].search([
                ('group_booking', '=', group_id)
            ])

            # Find master booking (where parent_booking_name is null)
            master_booking = bookings.filtered(lambda b: not b.parent_booking_name)

            if not master_booking:
                return False

            # Ensure we have exactly one master booking
            master_booking.ensure_one()

            # Return first room if multiple exist
            return master_booking.room_line_ids[0].room_id.id

    @api.depends('debit_amount', 'credit_amount')
    def _compute_price(self):
        for record in self:
            record.price = record.debit_amount or record.credit_amount

    @api.onchange('room_list', 'group_list')
    def _onchange_room_or_group(self):
        """Automatically find and suggest folio when room or group changes"""
        if self.room_list or self.group_list:
            domain = []
            if self.room_list:
                domain.append(('room_id', '=', self.room_list.id))
            if self.group_list:
                domain.append(('group_id', '=', self.group_list.id))

            if self.room_list and self.group_list:
                folio = self.env['tz.master.folio'].search([
                    '|',
                    ('room_id', '=', self.room_list.id),
                    ('group_id', '=', self.group_list.id)
                ], limit=1, order='create_date DESC')
            elif domain:
                folio = self.env['tz.master.folio'].search(domain, limit=1, order='create_date DESC')
            else:
                folio = False

    @api.onchange('item_id')
    def _onchange_item_id(self):
        if self.item_id:
            if self.sign == 'debit':
                self.credit_amount = 0.0
                self.debit_amount = self.item_id.default_value
            elif self.sign == 'credit':
                self.debit_amount = 0.0
                self.credit_amount = self.item_id.default_value
            self.description = self.item_id.description

    @api.onchange('type')
    def _onchange_type(self):
        self.room_list = False
        self.group_list = False

    def _create_master_folio(self, room_id):
        """
        Create master folio for manual posting when none exists
        Returns folio ID or raises exception
        """
        system_date = self.env.user.company_id.system_date.date()

        # check room id from
        booking_line = self.env['room.booking.line'].search([
            ('room_id', '=', room_id),
            ('checkin_date', '>=', fields.Datetime.to_datetime(system_date)),
            ('checkin_date', '<', fields.Datetime.to_datetime(system_date + timedelta(days=1))),
            ('state_', 'in', ['confirmed', 'check_in'])
        ], limit=1)

        domain = self._get_domain_filter(room_id, system_date)

        if booking_line.booking_id.group_booking:
            folio = self.env['tz.master.folio'].sudo().search(domain, limit=1)
            if not folio:
                company = self.env.company
                prefix = f"{company.name}/"
                folio_name = prefix + (self.env['ir.sequence'].sudo().with_company(company)
                                       .next_by_code('tz.master.folio'))

                folio_vals = {
                    'name': folio_name,
                    'guest_id': booking_line.booking_id.partner_id.id,
                    'rooming_info': booking_line.room_id.name,
                    'check_in': booking_line.checkin_date,
                    'check_out': booking_line.checkout_date,
                    'company_id': company.id,
                    'currency_id': company.currency_id.id,
                    'room_id': room_id,
                    'booking_ids': [(4, booking_line.booking_id.id)],
                }
                # raise UserError("\n".join([f"{key}: {value}" for key, value in folio_vals.items()]))
                folio = self.env['tz.master.folio'].sudo().create(folio_vals)
            return folio
        else:
            return self.env['tz.master.folio'].sudo().search(domain, limit=1)

    def _get_domain_filter(self, room_id, system_date):
        return [
                ('company_id', '=', self.env.company.id),
                ('room_id', '=', room_id),
                ('check_in', '>=', fields.Datetime.to_datetime(system_date)),
                ('check_in', '<', fields.Datetime.to_datetime(system_date + timedelta(days=1)))
            ]

    def unlink(self):
        for record in self:
            if record.state == 'posted':
                raise UserError(_("You cannot delete a record that is posted."))
        return super().unlink()

    @api.depends('item_id.default_sign')
    def _compute_sign(self):
        for rec in self:
            rec.sign = rec.item_id.default_sign

    @api.onchange('folio_id')
    def _onchange_folio_id(self):
        for rec in self:
            if rec.folio_id and rec.folio_id.group_id:
                rec.group_list = rec.folio_id.group_id
            else:
                rec.group_list = False

    @api.depends('folio_id')
    def _compute_group_list(self):
        self._onchange_folio_id()

    @api.constrains('item_id')
    def _check_item_default_sign(self):
        for record in self:
            if record.item_id and record.item_id.default_sign:
                raise UserError(
                    "This operation is not allowed because the selected item "
                    "has default_sign set to Debit or Credit. Please choose another item."
                )

