# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
_logger = logging.getLogger(__name__)


class TzHotelManualPosting(models.Model):
    """
    The Manual Postings form is a crucial part of the hotel’s financial system.
    It offers accountants and Front Office staff the ability to enter or adjust financial transactions that are not automatically generated by the system’s standard processes
    (e.g., daily room charges or integrated point-of-sale sales).
    """
    _name = 'tz.manual.posting'
    _order = 'create_date desc'
    _description = 'Hotel Manual Posting'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string="Transaction ID", readonly=True, index=True,
                                 default="New", help="Name or Reference of Manual Posting", tracking=True)

    date_shift = fields.Datetime(
        string="Date / Shift #",
        default=lambda self: self.env.user.company_id.system_date.replace(hour=0, minute=0, second=0, microsecond=0),
        readonly=True
    )

    company_id = fields.Many2one('res.company', string="Hotel",
                                 index=True,
                                 default=lambda self: self.env.company,
                                 readonly=True)



    item_id = fields.Many2one('posting.item', string="Item", index=True, required=True, tracking=True)
    item_description = fields.Char(related='item_id.description', string='Item Description')

    description = fields.Char(string=_("Description"), required=True,
                              translate=True)

    voucher = fields.Char(string="Voucher #", index=True, tracking=True)

    room_list = fields.Many2one(
        'hotel.room',
        string="Select Room",
        domain="[('id', 'in', unavailable_room_ids)]"
    )

    unavailable_room_ids = fields.Many2many(
        comodel_name='hotel.room',
        compute='_compute_unavailable_rooms',
        store=False,
    )

    group_list = fields.Many2one(
        'group.booking',
        string="Select Group",
        domain="[('status_code', '=', 'confirmed')]"
    )

    type = fields.Selection(
        [
            ('room', 'Room'),
            ('group', 'Group'),
        ],
        string="Type",
        default='room',
        tracking=True
    )

    price = fields.Float(string="Price", tracking=True, index=True)
    quantity = fields.Integer(string="Quantity", default=1, tracking=True, index=True)
    total = fields.Float(string="Total", tracking=True, index=True, compute='_compute_total', store=True)

    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        tracking=True,
        default=lambda self: self.env.company.currency_id
    )

    sign = fields.Selection(
        related='item_id.sign',
        string="Sign",
        store=True,
        tracking=True
    )

    taxes = fields.Many2one(
        related='item_id.taxes',
        string="Taxes",
        store=True,
        tracking=True
    )

    partner_id = fields.Many2one(
        'res.partner',
        string="Guest",
        compute='_compute_booking_info',
        store=True
    )

    reference_contact_ = fields.Char(
        string="Contact Reference",
        compute='_compute_booking_info',
        store=True
    )

    # @api.model
    @api.model_create_multi
    def create(self, vals_list):
        if not vals_list:
            return super(TzHotelManualPosting, self).create(vals_list)

        # Get or create the sequence
        sequence = self.env['ir.sequence'].sudo().search([
            ('code', '=', 'tz.manual.posting'),
            ('company_id', '=', self.env.company.id)
        ], limit=1)

        if not sequence:
            # Create the sequence if it doesn't exist
            sequence = self.env['ir.sequence'].sudo().create({
                'name': f'Manual Posting Reference - {self.env.company.name}',
                'code': 'tz.manual.posting',
                'prefix': f'{self.env.company.name}/',
                'padding': 5,
                'company_id': self.env.company.id,
                'currency_id': self.currency_id.id,
            })

        # Process each record
        records = self.env['tz.manual.posting']
        for vals in vals_list:
            try:
                # Generate sequence if needed
                if vals.get('name', 'New') == 'New':
                    vals['name'] = sequence.next_by_id()

                # Create the record
                record = super(TzHotelManualPosting, self).create([vals])
                records += record
                record.save_to_master_folio()

            except Exception as e:
                _logger.error("Failed to create manual posting: %s", str(e))
                continue  # Skip problematic records but continue with others

        return records

    # @api.depends('room_id.state_', 'room_id.room_id')
    def _compute_unavailable_rooms(self):
        for rec in self:
            unavailable_rooms = self.env['room.booking.line'].search([
                ('state_', 'in', ['confirmed', 'block', 'check_in']),
            ]).mapped('room_id.id')
            rec.unavailable_room_ids = unavailable_rooms

    @api.model
    def default_get(self, fields_list):
        res = super(TzHotelManualPosting, self).default_get(fields_list)
        unavailable_rooms = self.env['room.booking.line'].search([
            ('state_', 'in', ['confirmed', 'block', 'check_in']),
        ]).mapped('room_id.id')
        res['unavailable_room_ids'] = [(6, 0, unavailable_rooms)]
        return res

    @api.depends('price', 'quantity')
    def _compute_total(self):
        for record in self:
            record.total = record.price * record.quantity
            # record.list_price = record.price * record.quantity

    def save_to_master_folio(self):
        """
        Save manual posting to master folio with the following logic:
        1. Search for existing folio matching company, guest, room/group and system date
        2. If found: create only folio line
        3. If not found: create both folio header and line
        """
        self.ensure_one()

        # Prepare search domain
        domain = [
            ('company_id', '=', self.company_id.id),
            ('system_date', '=', self.date_shift)
        ]

        # Add room or group to domain based on posting type
        if self.type == 'room' and self.room_list:
            domain.append(('room_id', '=', self.room_list.id))
        elif self.type == 'group' and self.group_list:
            domain.append(('group_id', '=', self.group_list.id))

        # Add guest to domain if available
        # if self.guest_id:
        #     domain.append(('guest_id', '=', self.guest_id.id))

        # Search for existing folio
        folio = self.env['tz.master.folio'].sudo().search(domain, limit=1)

        # Create folio if not found
        if not folio:
            folio_vals = {
                'name': self.env['ir.sequence'].next_by_code('tz.master.folio') or 'New',
                'company_id': self.company_id.id,
                'system_date': self.date_shift,
                'room_id': self.room_list.id if self.type == 'room' else False,
                'group_id': self.group_list.id if self.type == 'group' else False,
                'guest_id': self.partner_id.id if self.partner_id else False,
                'check_in': self.date_shift
            }
            folio = self.env['tz.master.folio'].sudo().create(folio_vals)

        # Prepare folio line values
        line_vals = {
            'folio_id': folio.id,
            'date': fields.Date.context_today(self),
            'time': fields.Datetime.now().strftime('%H:%M %p'),
            'description': self.description or self.item_id.name,
            'voucher_number': self.voucher,
            'debit_amount': self.total if self.sign == 'debit' else 0.0,
            'credit_amount': self.total if self.sign == 'credit' else 0.0,
        }

        # Create folio line
        folio_line = self.env['tz.master.folio.line'].sudo().create(line_vals)

        # Return results
        return {
            'folio_id': folio.id,
            'folio_line_id': folio_line.id,
            'message': _("Posted to %s") % folio.name
        }

    @api.depends('room_list')
    def _compute_booking_info(self):
        for record in self:
            booking_line = self.env['room.booking.line'].search([
                ('room_id', '=', record.room_list.id),
                ('state_', 'in', ['confirmed', 'check_in'])
            ], limit=1)

            if booking_line and booking_line.booking_id:
                record.partner_id = booking_line.booking_id.partner_id
                record.reference_contact_ = booking_line.booking_id.reference_contact_
            else:
                record.partner_id = False
                record.reference_contact_ = False

    @api.onchange('room_list')
    def _onchange_room_list(self):
        if not self.room_list:
            self.partner_id = False
            self.reference_contact_ = False


class PostingItemInherit(models.Model):
    _inherit = 'posting.item'

    sign = fields.Selection(
        [
            ('debit', 'Debit'),
            ('credit', 'Credit'),
        ],
        string="Sign",
        help="Denotes whether the transaction is a charge (Debit) or a payment/credit (Credit)",
        tracking=True
    )